#include "BooleanModeller.hpp"

/**
 * Class used to apply bool operations on solids.
 * 
 * <br><br>Two 'Solid' objects are submitted to this class constructor. There is a methods for 
 * each bool operation. Each of these return a 'Solid' resulting from the application
 * of its operation into the submitted solids. 
 *  
 * <br><br>See: D. H. Laidlaw, W. B. Trumbore, and J. F. Hughes.  
 * "Constructive Solid Geometry for Polyhedral Objects" 
 * SIGGRAPH Proceedings, 1986, p.161.
 *  
 * @author Danilo Balby Silva Castanheira (danbalby@yahoo.com)
 * Translated to C++ by akatsia-games on github.com
 */
BooleanModeller::BooleanModeller(Solid solid1, Solid solid2)
	:object1(solid1)
	,object2(solid2)
{
	//split the faces so that none of them intercepts each other
	object1.splitFaces(object2);
	object2.splitFaces(object1);

	//classify faces as being inside or outside the other solid
	object1.classifyFaces(object2);
	object2.classifyFaces(object1);
}

//-------------------------------BOOLEAN_OPERATIONS-----------------------------//

/**
	* Gets the solid generated by the union of the two solids submitted to the constructor
	*
	* @return solid generated by the union of the two solids submitted to the constructor
	*/
Solid BooleanModeller::getUnion()
{
	return composeSolid(Face.OUTSIDE, Face.SAME, Face.OUTSIDE);
}

/**
	* Gets the solid generated by the intersection of the two solids submitted to the constructor
	*
	* @return solid generated by the intersection of the two solids submitted to the constructor.
	* The generated solid may be empty depending on the solids. In this case, it can't be used on a scene
	* graph. To check this, use the Solid.isEmpty() method.
	*/
Solid BooleanModeller::getIntersection()
{
	return composeSolid(Face.INSIDE, Face.SAME, Face.INSIDE);
}

/** Gets the solid generated by the difference of the two solids submitted to the constructor.
	* The fist solid is substracted by the second.
	*
	* @return solid generated by the difference of the two solids submitted to the constructor
	*/
Solid BooleanModeller::getDifference()
{
	object2.invertInsideFaces();
	Solid result = composeSolid(Face.OUTSIDE, Face.OPPOSITE, Face.INSIDE);
	object2.invertInsideFaces();

	return result;
}

//--------------------------PRIVATES--------------------------------------------//

/**
	* Composes a solid based on the faces status of the two operators solids:
	* Face.INSIDE, Face.OUTSIDE, Face.SAME, Face.OPPOSITE
	*
	* @param faceStatus1 status expected for the first solid faces
	* @param faceStatus2 other status expected for the first solid faces
	* (expected a status for the faces coincident with second solid faces)
	* @param faceStatus3 status expected for the second solid faces
	*/
Solid BooleanModeller::composeSolid(int faceStatus1, int faceStatus2, int faceStatus3)
{
	std::vector<Vertex> vertices;
	std::vector<int> indices;
	std::vector<Colour3f> colors;

	//group the elements of the two solids whose faces fit with the desired status
	groupObjectComponents(object1, vertices, indices, colors, faceStatus1, faceStatus2);
	groupObjectComponents(object2, vertices, indices, colors, faceStatus3, faceStatus3);

	//turn the arrayLists to arrays
	std::vector<Point3f> verticesArray = new Point3f[vertices.size()];
	for(int i=0;i<vertices.size();i++)
	{
		verticesArray[i] = ((Vertex)vertices.get(i)).getPosition();
	}
	std::vector<int> indicesArray = new int[indices.size()];
	for(int i=0;i<indices.size();i++)
	{
		indicesArray[i] = ((Integer)indices.get(i)).intValue();
	}
	std::vector<Colour3f> colorsArray = new Colour3f[colors.size()];
	for(int i=0;i<colors.size();i++)
	{
		colorsArray[i] = (Colour3f)((Colour3f)colors.get(i)).clone();
	}

	//returns the solid containing the grouped elements
	return new Solid(verticesArray, indicesArray, colorsArray);
}

/**
	* Fills solid arrays with data about faces of an object generated whose status
	* is as required
	*
	* @param object3d solid object used to fill the arrays
	* @param vertices vertices array to be filled
	* @param indices indices array to be filled
	* @param colors colors array to be filled
	* @param faceStatus1 a status expected for the faces used to to fill the data arrays
	* @param faceStatus2 a status expected for the faces used to to fill the data arrays
	*/
void BooleanModeller::groupObjectComponents(Object3D& object, std::vector<Vertex>& vertices, std::vector<int>& indices, std::vector<Colour3f>& colors, int faceStatus1, int faceStatus2)
{
	Face face;
	//for each face..
	for(int i=0;i<object.getNumFaces();i++)
	{
		face = object.getFace(i);
		//if the face status fits with the desired status...
		if(face.getStatus()==faceStatus1 || face.getStatus()==faceStatus2)
		{
			//adds the face elements into the arrays
			std::vector<Vertex> faceVerts = {face.v1, face.v2, face.v3};
			for(int j=0;j<faceVerts.length;j++)
			{
				if(vertices.contains(faceVerts[j]))
				{
					indices.add(new Integer(vertices.indexOf(faceVerts[j])));
				}
				else
				{
					indices.add(new Integer(vertices.size()));
					vertices.add(faceVerts[j]);
					colors.add(faceVerts[j].getColor());
				}
			}
		}
	}
}
