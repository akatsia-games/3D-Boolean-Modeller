#include "BooleanModeller.hpp"
#include <algorithm>

/**
 * Class used to apply bool operations on solids.
 * 
 * <br><br>Two 'Solid' objects are submitted to this class constructor. There is a methods for 
 * each bool operation. Each of these return a 'Solid' resulting from the application
 * of its operation into the submitted solids. 
 *  
 * <br><br>See: D. H. Laidlaw, W. B. Trumbore, and J. F. Hughes.  
 * "Constructive Solid Geometry for Polyhedral Objects" 
 * SIGGRAPH Proceedings, 1986, p.161.
 *  
 * @author Danilo Balby Silva Castanheira (danbalby@yahoo.com)
 * Translated to C++ by akatsia-games on github.com
 */
BooleanModeller::BooleanModeller(const Solid& solid1, const Solid& solid2)
	:object1(solid1)
	,object2(solid2)
{
	//split the faces so that none of them intercepts each other
	object1.splitFaces(object2);
	object2.splitFaces(object1);

	//classify faces as being inside or outside the other solid
	object1.classifyFaces(object2);
	object2.classifyFaces(object1);
}

//-------------------------------BOOLEAN_OPERATIONS-----------------------------//

/**
	* Gets the solid generated by the union of the two solids submitted to the constructor
	*
	* @return solid generated by the union of the two solids submitted to the constructor
	*/
Solid BooleanModeller::getUnion()
{
	return composeSolid(Face::OUTSIDE, Face::SAME, Face::OUTSIDE);
}

/**
	* Gets the solid generated by the intersection of the two solids submitted to the constructor
	*
	* @return solid generated by the intersection of the two solids submitted to the constructor.
	* The generated solid may be empty depending on the solids. In this case, it can't be used on a scene
	* graph. To check this, use the Solid.isEmpty() method.
	*/
Solid BooleanModeller::getIntersection()
{
	return composeSolid(Face::INSIDE, Face::SAME, Face::INSIDE);
}

/** Gets the solid generated by the difference of the two solids submitted to the constructor.
	* The fist solid is substracted by the second.
	*
	* @return solid generated by the difference of the two solids submitted to the constructor
	*/
Solid BooleanModeller::getDifference()
{
	object2.invertInsideFaces();
	Solid result = composeSolid(Face::OUTSIDE, Face::OPPOSITE, Face::INSIDE);
	object2.invertInsideFaces();

	return result;
}

//--------------------------PRIVATES--------------------------------------------//

/**
	* Composes a solid based on the faces status of the two operators solids:
	* Face::INSIDE, Face::OUTSIDE, Face::SAME, Face::OPPOSITE
	*
	* @param faceStatus1 status expected for the first solid faces
	* @param faceStatus2 other status expected for the first solid faces
	* (expected a status for the faces coincident with second solid faces)
	* @param faceStatus3 status expected for the second solid faces
	*/
Solid BooleanModeller::composeSolid(int faceStatus1, int faceStatus2, int faceStatus3)
{
	std::vector<Vertex> vertices;
	std::vector<int> indices;
	std::vector<Colour3f> colors;

	//group the elements of the two solids whose faces fit with the desired status
	groupObjectComponents(object1, vertices, indices, colors, faceStatus1, faceStatus2);
	groupObjectComponents(object2, vertices, indices, colors, faceStatus3, faceStatus3);

	//turn the Vertex vector to Point3d vector
	std::vector<Point3d> verticesArray(vertices.size());
	for(int i=0;i<vertices.size();i++)
	{
		verticesArray[i] = vertices[i].getPosition();
	}

	//returns the solid containing the grouped elements
	return Solid(verticesArray, indices, colors);
}

/**
	* Fills solid arrays with data about faces of an object generated whose status
	* is as required
	*
	* @param object3d solid object used to fill the arrays
	* @param vertices vertices array to be filled
	* @param indices indices array to be filled
	* @param colors colors array to be filled
	* @param faceStatus1 a status expected for the faces used to to fill the data arrays
	* @param faceStatus2 a status expected for the faces used to to fill the data arrays
	*/
void BooleanModeller::groupObjectComponents(Object3D& object, std::vector<Vertex>& vertices, std::vector<int>& indices, std::vector<Colour3f>& colors, int faceStatus1, int faceStatus2)
{
	//for each face..
	for(int i=0;i<object.getNumFaces();i++)
	{
		const Face& face = object.getFace(i);
		//if the face status fits with the desired status...
		if(face.getStatus()==faceStatus1 || face.getStatus()==faceStatus2)
		{
			//adds the face elements into the arrays
			std::vector<Vertex> faceVerts = {face.v1(), face.v2(), face.v3()};
			for(int j=0;j<faceVerts.size();j++)
			{
				auto it = std::find_if(vertices.begin(),vertices.end(),
					[&faceVerts,j](const Vertex& curr_vertex){return curr_vertex.equals(faceVerts[j]);});
				if(it != vertices.end())
				{
					indices.push_back(it - vertices.begin());
				}
				else
				{
					indices.push_back(vertices.size());
					vertices.push_back(faceVerts[j]);
					colors.push_back(faceVerts[j].getColor());
				}
			}
		}
	}
}
